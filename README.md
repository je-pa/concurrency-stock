# 동시성 이슈 해결 알아보기

## 1. synchronized
- synchronized를 사용하면 하나의 프로세스 안에서 스레드 동시 접근을 막는다.

### synchronized를 사용할 때 주의점이 있다.
1. @Transactional를 사용할 경우
   - 스프링에서 Transactional Annotation을 이용하면 우리가 만든 클래스를
     래핑한 클래스를 새로 만들어서 실행하게 된다.
  
   - 코드상에서는 stockservice를 필드로 가지는 클래스를 새로 만들어서 실행한다.
  
   - 트랜잭션을 시작한 후에 메소드를 호출하고 메소드 실행이 종료가 된다면 트랜잭션을 종료하는데,
    
     트랜잭션 종료 시점에 데이터베이스에 업데이트업데이트 한다.

   - 메소드가 완료가 되었고 실제 데이터베이스가 업데이트 되기 전에 다른 Thread가 Decrease Method를 호출할 수 있다.
     - 다른 Thread는 갱신되기 전에 값을 가져가서 이전과 동일한 문제가 발생하는 것이다.
   - 이는 @Transaction 없으면 해결되긴 한다.
2. Java의 Synchronized는 하나의 프로세스 안에서만 보장한다.
    - 서버가 1대일 때는 데이터의 접근을 서버가 1대만 해서 괜찮겠지만,
      
      서버가 2대 혹은 그 이상일 경우는 데이터의 접근을 여러 대에서 할 수 있게 된다.
   
      싱크로나이즈드는 각 프로세스 안에서만 보장이 되기 때문에 
    
      결국 여러 스레드에서 동시에 데이터에 접근을 할 수 있게 되면서 레이스 컨디션이 발생하게 된다.

> 실제 운영 중인 서비스는 대부분 2대 이상의 서버를 사용하기 때문에
> Synchronized는 거의 사용하지 않는다.
